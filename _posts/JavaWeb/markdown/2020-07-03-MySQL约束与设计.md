---
layout: post
title: "MySQL表的约束与数据库设计"
subtitle: "「查询语句、约束、设计」"
author: "月明"
date:  2020-7-3 23:00:00
header-img: "assets/background2.png"
header-mask: 0.3
tags:
  - JavaWeb
  - 学习笔记
  - MySQL
---

# DQL查询语句

## 排序

通过`order by` 子句，可以将查询出的结果进行排序(不影响数据库中数据的顺序)    

-----------------

```mysql
select 字段名 from 表名 where 字段=值 order by 字段名 [asc|desc];
```

### 单列排序

只按某一个字段进行排序，单列排序。

### 组合排序

同时对多个字段进行排序

```mysql
select 字段名 from 表名 where 字段=值 order by 字段名1[asc|desc],字段名2[asc|desc];
```

## 聚合函数

纵向查询，对一列的值进行计算，然后返回一个结果值。聚合函数会忽略空值NULL。

| SQL中的聚合函数 | 作用                   |
| --------------- | ---------------------- |
| **max(列名)**   | 求这一列的最大值       |
| **min(列名)**   | 求这一列的最小值       |
| **avg(列名)**   | 求这一列的平均值       |
| **count(列名)** | 统计这一列有多少条记录 |
| **sum(列名)**   | 对这一列求总和         |

```mysql
select 聚合函数(列名) from 表名;
```

`ifnull(列名,默认值)`如果列名不为空，返回这列的值。如果为NULL，则返回默认值。

## 分组

分组查询是指使用`group by` 语句对查询信息进行分组，相同数据作为一组

```mysql
select 字段1，字段2... from 表名 group by 分组字段[having 条件];
```

`group by`将分组字段结果中相同内容作为一组，并且返回每组的第一条数据。

分组的目的就是为了统计，`一般分组会跟聚合函数一起使用`

> 注意：当使用某个字段分组，在查询的时候也需要将这个字段查询出来，否则看不到数据属于哪组的。
>
> ex：select **sex**,count(*) from student where age > 25 group by **sex** having count(\*) >2;

### having 与 where 的区别

| 子名       | 作用                                                         |
| ---------- | :----------------------------------------------------------- |
| where 子句 | 1) 对查询结果进行分组前，将不符合where条件的行去掉，即在`分组之前`过滤数据，即先过滤再分组。                                                                                                                                                                             2) where后面`不可以`使用聚合函数 |
| having子句 | 1) having子句的作用是筛选满足条件的组，即在`分组之后`过滤数据，即先分组再过滤。                               2) having后面`可以`使用聚合函数 |

## limit语句

作用是限制查询记录的条数

```mysql
select *|字段列表 [as 别名] from 表名 [where 子句] [group by 子句] [having 子句][order by 子句] [limit 子句];
```

| limit offset,length;                                   |
| ------------------------------------------------------ |
| offset：起始**行数**，从0开始计数，如果省略，默认就是0 |
| length：返回的行数                                     |

# 数据库备份和还原

在服务器进行数据传输、数据存储和数据交换，就有可能产生数据故障。比如发生意外停机或存储介质损坏。

## 备份与还原的语句

### 备份格式：

DOS下，未登录的时候。可执行文件exe，在bin文件夹

`mysqldump -u 用户名 -p 密码 数据库 > 文件的路径`

> 导出结果：数据库中的所有表和数据都会导出成SQL语句

### 还原格式：

mysql中的命令，需要登录后才可以操作

`use 数据库;`

`source 导入文件的路径;`

## 图形化界面备份与还原

![备份](/assets/image/ed28b5f458370965c7475e673e4c9f6.png)

![备份](/assets/image/6b1071dcf971c56d7421e418a8232e8.png)

![备份](/assets/image/28f6edaeae74491ad09031bdfb0af09.png)

![备份](/assets/image/707d6cdf551e3313729b97eaff3b27f.png)

# 数据库表的约束

对表中的数据进行限制，保证数据的正确性、有效性和完整性。一个表如果添加了约束，不正确的数据将无法插入到表中。`约束在创建表的时候添加比较合适`

| 约束名           | 约束关键字             |
| ---------------- | ---------------------- |
| 主键(非空、唯一) | primary key            |
| 唯一             | unique                 |
| 非空             | not null               |
| 外键             | foreigh key            |
| 检查约束         | check  注：mysql不支持 |

## 主键约束

用来唯一标识数据库中的每一条记录

> 通常不用业务字段作为主键，单独给每张表设计一个id的字段，把id作为主键。`主键是给数据库和程序使用的，不是给最终的客户使用的。所以主键有没有含义没有关系，只要不重复，非空就行。`

`在创建表的时候给字段添加主键`

```mysql
字段名 字段类型 primary key
```

`在已有表中添加主键`

```mysql
alter table 表名 add primary key(字段名);
```

`删除主键`

```mysql
alter table 表名 drop primary key;
```

### 主键自增

通常希望在每次插入新纪录时，数据库自动生成主键字段的值

`auto_increment 表示自动增长(字段类型必须是整数类型)`

默认地auto_increment的开始值是1，如果希望修改起始值

`创建表时指定起始值`

```mysql
create table 表名(
	列名 int primary key auto_increment
)auto_increment=起始值;
```

`创建好以后修改起始值`

```mysql
alter table 表名 auto_increment=起始值;
```

* delete删除所有记录之后，自增长没有影响
* truncate 删除以后，自增长又重新开始

## 唯一约束

```mysql
字段名 字段类型 unique
```

> null 没有数据，不存在重复的问题

## 非空约束

某一列不能为null

```mysql
字段名 字段类型 not null
```

`默认值`

```mysql
字段名 字段类型 default 默认值
```

> 1. 主键数在一个表中，只能有一个。主键可以单列，也可以是多列
> 2. 自增长只能用在主键上

## 外键约束

* 外键：在从表中与主表主键对应的那一列
* 主表：一方，用来约束别人的表
* 从表：多方，被别人约束的表

`新建表时增加外键`

```mysql
[constraint][外键约束名称] foreign key (外键字段名) references 主表名(主键字段名)
```

`已有表增加外键`

```mysql
alter table 从表 add[constraint][外键约束名称] foreign key (外键字段名) references 主表(主键字段名);
```

`删除外键`

```mysql
alter table 从表 drop foreign key 外键名称;
```

`外键的级联`

在修改和删除主表的主键时，同时更新或删除副表的外键值

| 级联操作语法      | 描述                                                         |
| ----------------- | ------------------------------------------------------------ |
| on update cascade | 级联更新，只能是创建表的时候创建级联关系。更新主表中的主键，从表中的外键列也自动同步更新 |
| on delete cascade | 级联删除                                                     |

# 表与表之间的关系

## 一对多

一对多(1:n)：**最常用的关系** 如班级和学生，部门和员工，客户和订单，分类和商品

建表原则：在从表(多方)创建一个字段，字段作为外键指向主表(一方)的主键

## 多对多

多对多(m：n)：例如老师和学生，学生和课程，用户和角色

建表原则：需要创建第三张表，**中间表**中至少两个字段，这两个字段分别作为外键指向各自一方的主键。

## 一对一

一对一(1:1):在实际开发中应用不多，因为一对一可以创建成一张表 例如员工表 简历表 公民表 护照表

| 一对一的建表原则 | 说明                                                         |
| ---------------- | ------------------------------------------------------------ |
| 外键唯一         | 主表的主键和从表的外键(唯一)，形成主外键关系，外键唯一unique |
| 外键是主键       | 主表的主键和从表的主键，形成主外键关系                       |

# 数据库设计

## 数据规范化

好的数据库设计对数据的存储性能和后期的程序开发，都会产生重要的影响。建立科学的，规范的数据库就需要满足一些规则来优化数据的设计和存储，这些**规则**就称为范式。

### 三大范式

目前关系数据库有六种范式：第一范式(1NF)、第二范式(2NF)、第三范式(3NF)、巴斯-科德范式(BCNF)、第四范式(4NF)和第五范式(5NF，又称完美范式)

数据库只需满足第三范式(3NF)就行了

## 1NF

`第一范式每一列不可再拆分`

数据库表的每一列都是不可分割的原子数据项，不能是集合、数组等非原子数据项。即表中的某个列有多个值时，必须拆分为不同的列。

## 2NF

`第二范式就是在第一范式的基础上所有列完全依赖于主键列`

完全依赖是指不能存在仅依赖主键一部分的列。

第二范式特点：

1. 一张表只描述一件事情
2. 表中的每一列都完全依赖于主键

## 3NF

`第三范式就是所有列不依赖于其他所有非主键列，也就是`

`在满足2NF的基础上，任何非主列不得传递依赖于主键`

传递依赖，指的是如果存在“A->B->C”的决定关系，则C传递依赖于A。

满足第三范式的数据库表应该不存在如下依赖关系：主键列->非主键列x->非主键列y



