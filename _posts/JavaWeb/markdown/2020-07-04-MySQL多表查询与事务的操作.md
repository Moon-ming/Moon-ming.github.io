---
layout: post
title: "MySQL多表查询与事务的操作"
subtitle: "「内连接、隔离级别、DCL」"
author: "月明"
date:  2020-7-4 23:00:00
header-img: "assets/background3.png"
header-mask: 0.3
tags:
  - JavaWeb
  - 学习笔记
  - MySQL
---

# 表连接查询

## 多表查询

![多表查询结构](/assets/image/3e6476ad318a9f73af227e427e92e01.png)

## 笛卡尔积现象

并不是所有的数据组合都是有用的，需要通过条件过滤掉没用的数据。

## 内连接

`用左边的表的记录去匹配右边表的记录，如果符合条件的则显示。`如：**从表.外键=主表.主键**

* 隐式内连接：看不到join关键字，条件使用where指定

```mysql
select 字段名 from 左表，右表 where 条件
```

* 显示内连接：使用inner join ... on语句，可以省略inner

```mysql
select 字段名 from 左表 [inner] join 右表 on 条件
```

 步骤：

* 确定查询哪些表
* 确定表连接的条件
* 确定查询的条件
* 确定查询的字段

## 左外连接

`左外连接：使用left outer join ... on,outer 可以省略`

```mysql
select 字段名 from 左表 left [outer] join 右表 on 条件
```

用左边表的记录去匹配右边表的记录，如果符合条件的则显示；否则，显示null

可以理解为：在内连接的基础上**保证左表**的数据全部显示

## 右外连接

`右外连接：使用right outer join ... on，outer可以省略`

```mysql
select 字段名 from 左表 right [outer] join 右表 on 条件
```

可以理解为：在内连接的基础上保证右表的数据全部显示

# 子查询

`概念`：  

* 一个查询的结果做为另一个查询的条件
* 有查询的嵌套，内部的查询称为子查询
* 子查询要使用括号

`结果的三种情况`

* 单行单列

  * 肯定在**where**后面作为条件，父查询使用：比较远算符，如：>、<、<>、=等

  ```mysql
  select 查询字段 from 表 where 字段 = (子查询);
  ```

* 多行单列

  * 结果集类似于一个数组，父查询使用**IN**运算符

  ```mysql
  select 查询字段 from 表 where 字段 in (子查询);
  ```

* 多行多列

  * 肯定在**from**后面作为表

  ```mysql
  select 查询字段 from (子查询) 表别名 where 条件;
  ```

  子查询作为表需要取别名，否则这张表没有名称则无法访问表中的字段

# 事务

在实际的开发过程中，一个业务操作多次访问数据库才能完成的，如果其中有一条SQL语句出现异常，这条SQL就可能执行失败。

事务执行是一个整体，所有的SQL语句都必须执行成功。如果其中有一条SQL语句出现异常，则所有SQL语句都要回滚，整个业务执行失败。

## 手动提交事务

| 功能     | SQL语句              |
| -------- | -------------------- |
| 开启事务 | `start transaction;` |
| 提交事务 | `commit;`            |
| 回滚事务 | `rollback;`          |

![](/assets/image/d23934e9165a2f9af33e57e2579110a.png)

## 自动提交事务

MySQL默认每一条DML(增删改)语句都是一个单独的事务，每条语句都会自动开启一个事务，语句执行完毕自动提交事务，MySQL默认开始自动提交事务

### 取消自动提交

* 查看MySQL是否开启自动提交事务(1表示开启，0表示关闭)

  `select @@autocommit;`
  
* 取消自动提交事务

  `set @@autocommit = 0;`

## 事务原理

事务开启后，所有操作都会临时保存到**事务日志**中，只有在得到commit命令才会同步到数据表中，其他任何情况都会清空事务日志。

![](/assets/image/69a3b58ebb8b19b65f076aaea709816.png)

`事务的步骤`

* 客户端连接数据库服务器，创建连接时创建此用户临时日志文件
* 开启事务以后，所有的操作都会先写入到临时日志文件中
* 所有的查询操作从表中查询，但会经过日志文件加工后才返回
* 如果事务提交则将日志文件中的数据写到表中，否则清空日志文件

## 回滚点

在某些成功的操作完成之后，后续的操作有可能成功有可能失败，但是不管成功还是失败，前面操作都已经成功，可以在当前成功的位置设置一个回滚点。

| 回滚点的操作语句 | 语句               |
| ---------------- | ------------------ |
| 设置回滚点       | `savepoint 名字`   |
| 回到回滚点       | `rollback to 名字` |

## 事务的隔离级别

`事务的四大特性ACID`

| 事务特性            | 含义                                                         |
| ------------------- | ------------------------------------------------------------ |
| 原子性(Atomicity)   | 每个事务都是一个整体，不可再拆分，事务中所有的SQL语句要么都执行成功，要么都失败 |
| 一致性(Consistency) | 事务在执行前数据库的状态与执行后数据库的状态保持一致。       |
| 隔离性(Ioslation)   | 事务与事务之间不应该相互影响，执行时保持隔离的状态           |
| 持久性(Durability)  | 一旦事务执行成功，对数据库的修改时持久的。就算关机，也是保持下来的。 |

`因为并发操作，多个用户同时访问同一个数据，可能引发并发访问的问题`

| 并发访问的问题 | 含义                                                         |
| -------------- | ------------------------------------------------------------ |
| 脏读           | 一个事务读取到了**另一个**事务中尚**未提交**的数据           |
| 不可重复读     | 一个事务中两次读取的数据**内容**不一致，要求的是一个事务中多次读取时数据是一致的，这是事务update时引发的问题 |
| 幻读           | 一个事务中两次读取的数据的**数量**不一致，要求在一个事务多次读取的数据的数量是一致的，这是insert或delete时引发的问题 |

**解决脏读的问题：**将全局的隔离级别进行提升 (read committed 的方式可以避免脏读的发生)

**解决不可重复读的问题：**将全局的隔离级别进行提升为：repeatable read

> 同一事务中为了保证多次查询数据一致，必须使用repeatable read隔离级别

**挡住幻读：**使用serializable隔离级别，一个事务没有执行完，其他事务的SQL执行不了

`四种隔离级别`

> 隔离级别越高，性能越差，安全性越高

| 级别 | 名字     | 隔离级别         | 脏读 | 不可重复读 | 幻读 | 数据库默认隔离级别 |
| ---- | -------- | ---------------- | ---- | ---------- | ---- | ------------------ |
| 1    | 读未提交 | read uncommitted | 是   | 是         | 是   |                    |
| 2    | 读已提交 | read committed   | 否   | 是         | 是   | Oracle和SQL Server |
| 3    | 可重复读 | repeatable read  | 否   | 否         | 是   | MySQL              |
| 4    | 串行化   | serializable     | 否   | 否         | 否   |                    |

`MySQL事务隔离级别相关的命令`

* 查询全局事务隔离级别

  `查询隔离级别	select @@tx_isolation;`

* 设置事务隔离级别，需要退出MySQL再重新登录才能看到隔离级别的变化

  `设置隔离级别	set global transaction isolation level 级别字符串;`

# DCL(Data Control Language)

* DDL： create/alter/drop
* DML: insert/update/delete
* DQL: select/show
* DCL: grant/revoke

一个公司里面的数据库服务器上面可能同时运行着很多个项目的数据库。应该根据不同的项目建立不同的用户，分配不同的权限来管理和维护数据库。

> mysqld是MySQL的主程序，服务器端。mysql是MySQL的命令行工具，客户端。

`创建用户`

```mysql
create user '用户名' @ '主机名' identified by '密码';
```

| 关键字   | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| '用户名' | 将创建的用户名                                               |
| '主机名' | 指定该用户在哪个主机上可以登录，如果是本地用户可用localhost，如果想让该用户可以从任意远程主机登陆，可以使用通配符`%` |
| '密码'   | 该用户的登陆密码，密码可以为空，如果为空则该用户可以不需要密码登陆服务器 |

> 创建的用户名都在mysql数据库中的user表中可以查看到，密码经过了加密

`给用户授权`

```mysql
grant 权限1, 权限2... on 数据库名.表名 to '用户名' @ '主机名';
```

| 关键字               | 说明                                                         |
| -------------------- | ------------------------------------------------------------ |
| grant on to          | 授权关键字                                                   |
| 权限                 | 授予用户的权限，如：create、alter、select、insert、update等。如果要授予所有权限则使用all |
| 数据库名.表名        | 该用户可以操作那个数据库的哪些表。如果要授权该用户对所有数据库和表的相应操作权限则可用 *  表示，如 * . * |
| '用户名' @ ' 主机名' | 给哪个用户授权，有2对单引号                                  |

`撤销授权`

```mysql
revoke 权限1,权限2... on 数据库.表名 revoke all on test.* from 'user1'@ 'localhost';
```

| 关键字              | X                |
| ------------------- | ---------------- |
| revoke on from      | 撤销授权的关键字 |
| 权限                | 用户的权限       |
| 数据库名.表名       |                  |
| '用户名' @ '主机名' | 给哪个用户撤销   |

`查看权限`

```mysql
show grants for '用户名' @ '主机名';
```

> usage 是指连接(登陆)权限，建立一个用户，就会自动授权其usage权限(默认授予)

`删除用户`

```mysql
drop user '用户名' @ '主机名';
```

`修改管理员密码`

```mysql
mysqladmin -uroot -p password 新密码
```

> 需要在未登录MySQL的情况下操作，新密码不需要加上引号

`修改普通用户密码`

```mysql
set password for '用户名' @ '主机名' = password('新密码');
```

> 需要在登陆MySQL的情况下操作，新密码要加单引号。



















