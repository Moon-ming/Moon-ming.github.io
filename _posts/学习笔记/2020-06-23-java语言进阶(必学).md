---
layout: post
title: "Java语言进阶"
subtitle: "「个人学习记录」"
author: "月明"
date:       2020-06-24 13:46:00
header-img: "assets/background.png"
header-mask: 0.3
tags:
  - 学习笔记
  - Java
---
# day01_Object类、常用API

**java.lang.Object** 类是Java语言中的根类，即所有类的父类。

**toString方法**
``` java
public String toString() 返回该对象的字符串表示。
该字符串内容就是对象的类型+\@+内存地址值。在开发中，经常需要按照对象的属性得到相应的字符串表现形式，因此也需要重写它
```

    在IntelliJ IDEA中，可以点击 Code 菜单中的 Generate... ，也可以使用快捷键alt+insert ，点击 toString() 选项。选择需要包含的成员变量并确定。

**equals方法**
``` java
public boolean equals(Object obj) 指示其他某个对象是否与此对象“相等”。判断这两个对象是否是相同的。这里的“相同”有默认和自定义两种方式
```

- 默认进行 == 运算符的对象地址比较，只要不是同一个对象，结果 必然为false。如果希望进行对象的内容比较，即所有或指定的部分成员变量相同就判定两个对象相同，则可以覆盖重写equals方法。
    - 如果对象地址一样，则认为相同
    - 如果参数为空，或者类型信息不一样，则认为不同
    - 转换为当前类型
    - a.util.Objects类的equals静态方法取用结果

在IntelliJ IDEA中，可以使用 Code 菜单中的 Generate… 选项，也可以使用快捷键alt+insert ，并选 择 equals() and hashCode() 进行自动代码生成。

**Objects类**

在JDK7添加了一个Objects工具类，它提供了一些方法来操作对象，它由一些静态的实用方法组成，这些方法是
null-save（空指针安全的）或null-tolerant（容忍空指针的），用于计算对象的hashcode、返回对象的字符串表示形式、比较两个对象。

在比较两个对象的时候，Object的equals方法容易抛出空指针异常，而Objects类中的equals方法就优化了这个问题。方法如下：
``` java
public static boolean equals(Object a, Object b) 判断两个对象是否相等
```


**日期时间类**

    java.util.Date类 表示特定的瞬间，精确到毫秒。
``` java
public Date() 分配Date对象并初始化此对象，以表示分配它的时间（精确到毫秒）

public Date(long date) 分配Date对象并初始化此对象，以表示自从标准基准时间（称为“历元（epoch）”，即1970年1月1日00:00:00 GMT）以来的指定毫秒数

public long getTime() 把日期对象转换成对应的时间毫秒值。
```
简单来说：使用无参构造，可以自动设置当前系统时间的毫秒时刻；指定long类型的构造参数，可以自定义毫秒时刻。

**java.text.DateFormat**
是日期/时间格式化子类的抽象类，我们通过这个类可以帮我们完成日期和文本之间的转换,也就是可以在Date对象与String对象之间进行来回转换。

**DataFormat类**

java.text.DateFormat是日期/时间格式化子类的抽象类，我们通过这个类可以帮我们完成日期和文本之间的转换,也就是可以在Date对象与String对象之间进行来回转换。

需要常用的子类 java.text.SimpleDateFormat 。这个类需要一个
模式（格式）来指定格式化(从Date对象转换为String对象)或解析(从String对象转换为Date对象)的标准。

![](/assets/image/media/609c2317c6c6c016c79971ae633e33e3.png)

                                                  格式规则

``` java
public SimpleDateFormat(String pattern) 用给定的模式和默认语言环境的日期格式符号构造 SimpleDateFormat。

public String format(Date date) 将Date对象格式化为字符串。

public Date parse(String source) 将字符串解析为Date对象。
```

**java.util.Calendar**
是(抽象类)日历类，在Date后出现，替换掉了许多Date的方法。该类将所有可能用到的时间信息封装为静态成员变量，方便获取。日历类就是方便获取各个时间属性的。

Calendar类在创建对象时并非直接创建，而是通过静态方法创建，返回子类对象
``` java
public static Calendar getInstance() 使用默认时区和语言环境获得一个日历

public int get(int field)  返回给定日历字段的值

public void set(int field, int value) 将给定的日历字段设置为给定值

public abstract void add(int field, int amount) 根据日历的规则，为给定的日历字段添加或减去指 定的时间量

public Date getTime() 返回一个表示此Calendar时间值（从历元到现在的毫秒偏移量）的Date对象给定的日历字段
```

![](/assets/image/media/9b194ca638a6e3bacb0b9f5cd19b4049.png)

                                                 System类

``` java
public static long currentTimeMillis() 返回以毫秒为单位的当前时间
public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length) 将数组中指定的数据拷贝到另一个数组中
```

    数组的拷贝动作是系统级的，性能很高

![](/assets/image/media/17bf5f5c72fc517709a9c9e68f0bcce0.png)

                                                参数含义

**StringBuilder类**

==字符串拼接问题==，String类的对象内容不可改。，每次拼接，都会构建一个新的String对象，既耗时，又浪费空间。

**java.lang.StringBuilder**为可变字符序列，字符串缓冲区，即它是一个容器，容器中可以装很多字符串。并且能够对其中的字符串进行各种操作。

内部拥有一个数组，自动维护数组的扩容。(默认16字符空间，超过自动扩充)

![](/assets/image/media/53d2c8080f05ec18010d2933933b9476.png)

 **构造方法**
``` java
 public StringBuilder() 构造一个空的StringBuilder容器。
 public StringBuilder(String str) 构造一个StringBuilder容器，并将字符串添加进去
```
 
 **常用方法**
``` java
public StringBuilder append(...) 添加**任意类型**数据的字符串形式，并返回当前对象自身

public String toString() 将当前StringBuilder对象转换为不可变String对象
```

    在我们开发中，会遇到调用一个方法后，返回一个对象的情况。然后使用返回的对象继续调用方法。这种时候，我们就可以把代码写在一起，如append方法一样，代码如下:
        链式编程
        builder.append("hello").append("world").append(true).append(100);

**包装类**

    装箱：从基本类型转换为对应的包装类对象。
    拆箱：从包装类对象转换为对应的基本类型（看懂代码即可）

从Java 5（JDK 1.5）开始，基本类型与包装类的装箱、拆箱动作可以自动完成
基本类型转换为String：基本类型直接与””相连接即可String转换成对应的基本类型

 除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型：
 
``` java
public static byte parseByte(String s) 将字符串参数转换为对应的byte基本类型

public static short parseShort(String s) 将字符串参数转换为对应的short基本类型

public static int parseInt(String s)将字符串参数转换为对应的int基本类型

public static long parseLong(String s) 将字符串参数转换为对应的long基本类型

public static float parseFloat(String s) 将字符串参数转换为对应的ﬂoat基本类型

 public static double parseDouble(String s) 将字符串参数转换为对应的double基本类型。

public static boolean parseBoolean(String s) 将字符串参数转换为对应的boolean基本类型
```
 
    注意:如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出java.lang.NumberFormatException 异常

# day02_Collection、泛型

在开发中一般当对象多的时候，使用集合进行存储。
集合按照其存储结构可以分为两大类，分别是单列集合 **java.util.Collection**和双列集合**java.util.Map**
## Collection：

**java.util.List**（有序，可重复）：java.util.ArrayList 和 java.util.LinkedList

**java.util.Set**（无序，不可重复）：java.util.HashSet 和 java.util.TreeSet

![](/assets/image/media/5cf8edb44f0ba4d0901ed47ba52eb7f4.png)

### Collection 常用功能：
```java
public boolean add(E e) 把给定的对象添加到当前集合中。

public void clear() 清空集合中所有的元素

public boolean remove(E e)  把给定的对象在当前集合中删除

public boolean contains(E e)  判断当前集合中是否包含给定的对象。

public boolean isEmpty()  判断当前集合是否为空

public int size()  返回集合中元素的个数

public Object[] toArray()  把集合中的元素，存储到数组中
```


#### List接口中常用方法: (跟索引相关)

```java
public void add(int index, E element) 将指定的元素，添加到该集合中的指定位置上

public E get(int index)  返回集合中指定位置的元素

public E remove(int index)
移除列表中指定位置的元素,返回的是被移除的元素

public E set(int index, E element) 用指定元素替换集合中指定位置的元素,返回值的更新前的元素
```

 Set接口与 Collection 接口中的方法基本一致，并没有对 Collection接口进行功能上的扩充，只是比 Collection 接口更加严格了。

**Iterator迭代器**

    在程序开发中，经常需要遍历集合中的所有元素。Iterator 主要用于迭代访问（即遍历）Collection 中的元 素，因此 Iterator 对象也被称为迭代器。
```java
public boolean hasNext() :如果仍有元素可以迭代，则返回 true。

public E next() :返回迭代的下一个元素。
```

    注意：在进行集合元素取出时，如果集合中已经没有元素了，还继续使用迭代器的next方法，将会发生java.util.NoSuchElementException没有集合元素的错误。

增强for循环(也称for each循环)，专门用来遍历数组和集合的。它的内部原
理其实是个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。

泛型：可以在类或方法中预支地使用未知的类型。

集合中是可以存放任意对象的，只要把对象存储集合后，那么这时他们都会被提升成Object类型。当我们在取出每一个对象，并且进行相应的操作，这时必须采用类型转换。

    注意：java.lang.ClassCastException。类型转换异常

好处：将运行时期的ClassCastException，转移到了编译时期变成了编译失败。
避免了类型强转的麻烦。

当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符\<?\>表示。但是一旦使用泛型的通配
符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。此时只能接受数据,不能往该集合中存储数据

在JAVA的泛型中可以指定一个泛型的上限（只能接收该类型及其子类）和下限（只能接收该类型及其父类型）。

# day03_List、Set、数据结构、Collections

数据存储的常用结构有：

栈：stack,又称堆栈，它是运算受限的线性表

队列：queue,简称队，它同堆栈一样，也是一种运算受限的线性表

>   数组：Array,是有序的元素序列，数组是在内存中开辟一段连续的空间，并在此空间存放元素

>   链表：linked
>   list,由一系列结点node（链表中每一个元素称为结点）组成，结点可以在运行时i动态生成

红黑树：一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。树的键值仍然是有序的。

![](/assets/image/media/a0b4fc3442f605313b5b0867ad5872f1.png)

- 约束:
    - 节点可以是红色的或者黑色的
    - 根节点是黑色的
    - 叶子节点(特指空节点)是黑色的
    - 每个红色节点的子节点都是黑色的
    - 任何一个节点到其每一个叶子节点的所有路径上黑色节点数相同

特点: 速度特别快,趋近平衡树,查找叶子元素少和多次数不多于二倍

## List的子类

java.util.ArrayList 集合数据存储的结构是**数组**结构。

    由于日常开发中使用多的功能为查询数据、遍历数据，所以 ArrayList 是最常用的集合。

**java.util.LinkedList**
集合数据存储的结构是（双向）链表结构。方便元素添加、删除的集合。

实际开发中对一个集合元素的添加与删除经常涉及到首尾操作，而LinkedList提供了大量首尾操作的方法。这些方法我们作为了解即可：

>   public void addFirst(E e) :将指定元素插入此列表的开头。
>   public void addLast(E e) :将指定元素添加到此列表的结尾。 public E getFirst()
>   :返回此列表的第一个元素。

>   public E getLast() :返回此列表的后一个元素。

>   public E removeFirst() :移除并返回此列表的第一个元素。 public E removeLast()
>   :移除并返回此列表的后一个元素。

>   public E pop() :从此列表所表示的堆栈处弹出一个元素。 public void push(E e)
>   :将元素推入此列表所表示的堆栈。 public boolean isEmpty()
>   ：如果列表不包含元素，则返回true。

    在开发时，LinkedList集合也可以作为堆栈，队列的结构使用

## Set的子类

java.util.HashSet 底层的实现其实是一个 java.util.HashMap 支持。

HashSet是根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。保证元素唯一性的方式依赖于：hashCode 与 equals 方法。

哈希表
>   在JDK1.8之前，哈希表底层采用数组+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。
>   但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，哈希表存储采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。

![](/assets/image/media/9fbc7f4f749bc1d1b627081753cdeee4.png)

JDK1.8引入红黑树大程度优化了HashMap的性能

### HashSet的子类

java.util.LinkedHashSet，它是链表和哈希表组合的一个数据存储结构。唯一，保证有序。

#### 可变参数

修饰符 返回值类型 方法名(参数类型... 形参名){  }

可以直接传递数据即可。...
用在参数上，称之为可变参数。同样是代表数组，但是在调用这个带有可变参数的方法时，不用创建数组(这就是简单之处)，直接将数组中的元素作为实际参数进行传递，其实编译成的class文件，将这些元素先封装到一个数组中，在进行传递。这些动作都在编译.class文件时，自动完成了。

## Collections

**java.utils.Collections** 是集合工具类，用来对集合进行操作。

>   public static \<T\> boolean addAll(Collection\<T\> c, T... elements)
>   :往集合中添加一些元素。

>   public static void shuffle(List\<?\> list) 打乱顺序 :打乱集合顺序。
>   public static \<T\> void sort(List\<T\> list)
>   :将集合中元素按照默认规则排序。

实际上要求了被排序的类型需要实现Comparable接口完成比较的功能，在String类型上实现，并完成了比较规则的定义。

>   public static \<T\> void sort(List\<T\> list，Comparator\<? super T\> )
>   :将集合中元素按照指定规则排序。

### 排序

在JAVA中提供了两种比较实现的方式：
比较死板的采用 java.lang.Comparable 接口去实现
灵活的当我需要做排序的时候在去选择的 java.util.Comparator 接口完成。

排序是comparator能实现的功能之一,该接口代表一个比较器，比较器具有可比性！顾名思义就是做排序的，通俗地讲需要比较两个对象谁排在前谁排在后，那么比较的方法就是：

>   **public int compare(String o1, String o2) ：比较其两个参数的顺序。**

>   **两个对象比较的结果有三种：大于，等于，小于。 如果要按照升序（o1-o2）排序，
>   则o1 小于o2，返回（负数），相等返回0，01大于02返回（正数） 如果要按照
>   降序（o2-o1）排序 则o1
>   小于o2，返回（正数），相等返回0，01大于02返回（负数）**

#### 简述Comparable和Comparator两个接口的区别

Comparable：强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的compareTo方法
被称为它的自然比较方法。只能在类中实现compareTo()一次，不能经常修改类的代码实现自己想要的排序。实现
此接口的对象列表（和数组）可以通过Collections.sort（和Arrays.sort）进行自动排序，对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。

 Comparator强行对某个对象进行整体排序。可以将Comparator传递给sort方法（如Collections.sort或Arrays.sort），从而允许在排序顺序上实现精确控制。还可以使用Comparator来控制某些数据结构（如有序set或有序映射）的顺序，或者为那些没有自然顺序的对象collection提供排序。

# day04_Map

## Map的子类

HashMap：存储数据采用的哈希表结构，元素的存取顺序不能保证一致。由于要保证键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。

LinkedHashMap：HashMap下的子类，存储数据采用的哈希表结构+链表结构。通过链表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证的键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。

    注意：Map接口中的集合都有两个泛型变量,在使用时，要为两个泛型变量赋予数据类型。两个泛型变量的数据类型可以相同，也可以不同。

### Map的常用方法：

>   public V put(K key, V value) : 把指定的键与指定的值添加到Map集合中。

>   public V remove(Object key) : 把指定的键 所对应的键值对元素
>   在Map集合中删除，返回被删除元素的 值。

>   public V get(Object key) 根据指定的键，在Map集合中获取对应的值。
>   public Set\<K\> keySet() : 获取Map集合中所有的键，存储到Set集合中。
>   public Set\<Map.Entry\<K,V\>\> entrySet() :
>   获取到Map集合中所有的键值对对象的集合(Set集合)

    注意：使用put方法时，若指定的键(key)在集合中没有，则没有这个键对应的值，返回null，并把指定的键值添加到集合中；
    若指定的键(key)在集合中存在，则返回值为集合中键对应的值（该值为替换前的值），并把指定键所对应的值，替换成指定的新值。

## Map集合遍历键找值方式

键找值方式：即通过元素中的键，获取键所对应的值

- 分析步骤：
    - 获取Map中所有的键，由于键是唯一的，所以返回一个Set集合存储所有的键。方法提示:keyset()
    - 遍历键的Set集合，得到每一个键。
    - 根据键，获取键所对应的值。方法提示:get(K key)

Map集合遍历键值对方式

键值对方式：即通过集合中每个键值对(Entry)对象，获取键值对(Entry)对象中的键与值。

- 操作步骤与图解：
    - 获取Map集合中，所有的键值对(Entry)对象，以Set集合形式返回。方法提示:entrySet()
    - 遍历包含键值对(Entry)对象的Set集合，得到每一个键值对(Entry)对象。
    - 通过键值对(Entry)对象，获取Entry对象中的键与值。方法提示: getkey() getValue()

如果要保证map中存放的key和取出的顺序一致，可以使用 java.util.LinkedHashMap
集合来存放。

Java9，添加了几种集合工厂方法,更方便创建少量元素的集合、map实例。新的List、Set、Map的静态工厂方法可
以更方便地创建集合的不可变实例。

of()方法只是Map，List，Set这三个接口的静态方法，其父类接口和子类实现并没有这类方法，比如
HashSet，ArrayList等。返回的集合是不可变的；

# day05_异常，线程
Java处理异常的方式是中断处理。
java.lang.Throwable：java.lang.Error 与 java.lang.Exception（异常）

## 常用方法：

>   public void printStackTrace() :打印异常的详细信息。
>   包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。

>   public String getMessage() :获取发生异常的原因。
>   提示给用户的时候,就提示错误原因。

> public String toString() :获取异常的类型和异常描述信息(不用)。

### 分类

编译时期异常:checked异常。在编译时期,就会检查,如果没有处理异常,则编译失败。(如日期格式化异常)

运行时期异常:runtime异常。在运行时期,检查异常.在编译时期,运行异常不会编译器检测(不报错)。(如数学异常)

### 处理

try…catch…ﬁnally：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理。

在ﬁnally代码块中存放的代码都是一定会被执行的。当只有在try或者catch中调用退出JVM的相关方法,此时ﬁnally才不会执行,否则ﬁnally永远会执行。

throw：throw用在方法内，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。

throws：运用于方法声明之上,用于表示当前方法不处理异常,而是提醒该方法的调用者来处理异常(抛出异常).
若该方法可能有多种异常情况产生，那么在throws后面可以写多个异常类，用逗号隔开。

### 异常注意事项

运行时异常被抛出可以不处理。即不捕获也不声明抛出。

如果ﬁnally有return语句,永远返回ﬁnally中的结果,避免该情况.

如果父类抛出了多个异常,子类重写父类方法时,抛出和父类相同的异常或者是父类异常的子类或者不抛出异常。

父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出。

### 自定义异常

在开发中根据自己业务的异常情况来定义异常类

定义
自定义一个编译期异常: 自定义类 并继承于 java.lang.Exception 。
自定义一个运行时期的异常类:自定义类并继承于 java.lang.RuntimeException

并发：指两个或多个事件在同一个时间段内发生。

并行：指两个或多个事件在同一时刻发生（同时发生）

![](/assets/image/media/d21506ea83e11f85ddb52e8a829525a3.png)

一个程序运行后至少有一个进程，一个进程中可以包含多个线程（多线程程序）。多线程程序并不能提高程序的运行速度，但能够提高程序运行效率，让CPU的使用率更高。

线程调度：当系统只有一个CPU时，线程会以某种顺序执行多个线程

分时调度：所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。

抢占式调度：优先让优先级高的线程使用CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，

Java使用的为抢占式调度。设置线程的优先级

# day06_线程、同步

线程类java.lang.Thread类代表线程。每个线程的作用是完成一定的任务，实际上就是执行一段程序流（线程执行体），即一段顺序执行的代码。

## 常用方法：

> public String getName() :获取当前线程名称。

>   public void start() :导致此线程开始执行; Java虚拟机调用此线程的run方法。

> public void run() :此线程要执行的任务在此处定义代码。

>   public static void sleep(long millis)
>   :使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。

>   public static Thread currentThread() :返回对当前正在执行的线程对象的引用。

- 创建并启动多线程的步骤
    - 定义Thread类的子类(extendsThread)，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务,因此把run()方法称为线程执行体。
    - 创建Thread子类的实例，即创建了线程对象
    - 调用线程对象的start()方法来启动该线程

创建线程方式二采用 java.lang.Runnable 也是非常常见的一种，我们只需要重写run方法即可。

- 步骤：
    - 定义Runnable接口的实现类(implements Runnable)，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。
    - 创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。
    - 调用线程对象的start()方法来启动线程。

    注意：Runnable对象仅仅作为Thread对象的target，Runnable实现类里包含的run()方法仅作为线程执行体。而实际的线程对象依然是Thread实例，只是该Thread线程负责执行其target的run()方法。

Thread类实际上也是实现了Runnable接口的类，不管是继承Thread类还是实现Runnable接口来实现多线程，最终还是通过Thread的对象的API来控制线程的，熟悉Thread类的API是进行多线程编程的基础。

Thread和Runnable的区别

实现Runnable接口比继承Thread类所具有的优势：

    适合多个相同的程序代码的线程去共享同一个资源。可以避免java中的单继承的局限性。
    增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。
    线程池只能放入实现Runable或Callable类线程，不能直接放入继承Thread的类
    使用线程的内匿名内部类方式，可以方便的实现每个线程执行不同的线程任务操作。使用匿名内部类的方式实现Runnable接口，重新Runnable接口中的run方法。

### 线程安全

程序每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的。

线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。

### Java中提供了同步机制
(synchronized)来解决。在某个线程修改共享资源的时候，其他线程不能修改该资源，等待修改完毕同步之后，才能去抢夺CPU资源，完成对应的操作，保证了数据的同步性，解决了线程不安全的现象。

#### 三种方式完成同步操作

#####同步代码块。
synchronized关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问

- synchronized(同步锁){需要同步操作的代码}

- 同步锁(lock)只是一个概念，可以是任意类型，多个线程共用

##### 同步方法。

使用synchronized修饰的方法,就叫做同步方法,保证A线程执行该方法的时候,其他线程只能在方法外等着。

>   public synchronized void method(){可能会产生线程安全问题的代码}

>   对于非static方法,同步锁就是this。

>   对于static方法,我们使用当前方法所在类的字节码对象(类名.class)

##### 锁机制。
java.util.concurrent.locks.Lock提供了更广泛的锁定操作，1、2具有的功能Lock都有,除此之外更强大,更体现面向对象。

>   public void lock() :加同步锁。

>   public void unlock() :释放同步锁。

线程状态

在API中 java.lang.Thread.State 这个枚举中给出了六种线程状态：

![](/assets/image/media/47975f0d83237acab9b12eb88e4eccd6.png)

Timed
Waiting(计时等待)：调用了sleep方法之后，当前执行的线程就进入到“休眠状态”

sleep与锁无关，线程睡眠到期自动苏醒，并返回到Runnable（可运行）状态。sleep()中指定的时间是线程不会运行的最短时间。因此，sleep()方法不能保证该线程睡眠到期后就开始立刻执行。

![](/assets/image/media/6e7e13ceee860ef46968d4b9ad87c32c.png)

Timed Waiting(计时等待)线程状态图

![](/assets/image/media/febb826fe7e387ebd99cbbe17d81df48.png)

Blocked(阻塞)线程状态图

![](/assets/image/media/3a9d62e3460461086c11f03d3f3bea6c.png)

Waiting(无限等待)线程状态图

一个调用了某个对象的 Object.wait方法的线程会等待另一个线程调用此对象的
Object.notify()方法 或 Object.notifyAll()方法。

waiting状态并不是一个线程的操作，它体现的是多个线程间的通信，可以理解为多个线程之间的协作关系，
多个线程会争取锁，同时相互之间又存在协作关系。

# day07_等待与唤醒案例、线程池、Lambda表达式

线程通信：

默认情况下CPU是随机切换线程的，需要多个线程来共同完成一件任务，并且我们希望他们有规律的执行,
那么多线程之间需要一些协调通信。

等待唤醒机制

多个线程间的一种协作机制。在一个线程进行了规定操作后，就进入等待状态wait()，
等待其他线程执行完他们的指定代码过后 再将
其唤醒notify();在有多个线程进行等待时，如果需要，可以使用
notifyAll()来唤醒所有的等待线程。 wait/notify
就是线程间的一种协作机制。用于解决线程间通信的问题。

## 方法：

wait：线程不再活动，不再参与调度，进入 wait set 中，因此不会浪费 CPU资源，也不会去竞争锁了，这时的线程状态即是WAITING。它还要等着别的线程执行一个特别的动作，也即是“通知（notify）”在这个对象上等待的线程从wait set 中释放出来，重新进入到调度队列（ready queue）中

如果能获取锁，线程就从 WAITING 状态变成 RUNNABLE 状态；否则，从 wait set出来，又进入 entry set，线程就从 WAITING 状态又变成 BLOCKED 状态

notify：则选取所通知对象的 wait set中的一个线程释放

notifyAll：则释放所通知对象的 wait set 上的全部线程。

    注意：wait方法与notify方法必须要由同一个锁对象调用，属于Object类的方法的，必须要在同步代码块或者是同步函数中使用。

线程池

容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，
无需反复创建线程而消耗过多资源。

好处

    降低资源消耗。减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。
    提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。
    提高线程的可管理性。可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。

java.util.concurrent.Executor线程工厂类(执行线程的工具)，官方建议

java.util.concurrent.ExecutorService线程池接口

Executors类中有创建线程池的方法：

public static ExecutorService newFixedThreadPool(int nThreads)
：返回线程池对象。(创建的是有界线程池,也就是池中的线程个数可以指定最大数量)

使用方法：

public Future\<?\> submit(Runnable task) :获取线程池中的某一个线程对象，并执行
Future接口：用来记录线程任务执行完毕后产生的结果。线程池创建与使用。

- 步骤：
    - 创建线程池对象。
ExecutorService service = Executors.newFixedThreadPool(2);//包含2个线程对象
    - 创建Runnable接口子类对象。(task) MyRunnable r = new MyRunnable();
    - 提交Runnable接口子类对象。(take task)
service.submit(r);
    - 关闭线程池(一般不做)。
//service.shutdown();

### Lambda表达式

格式由3个部分组成：

一些参数

一个箭头

一段代码

Lambda表达式的标准格式为：

(参数类型 参数名称) ‐\> { 代码语句 }

小括号内的语法与传统方法参数列表一致：无参数则留空；多个参数则用逗号分隔。

\-\> 是新引入的语法格式，代表指向动作。

大括号内的语法与传统方法体要求基本一致

省略规则

在Lambda标准格式的基础上，使用省略写法的规则为：

小括号内参数的类型可以省略；

如果小括号内有且仅有一个参，则小括号可以省略；

如果大括号内有且仅有一个语句，则无论是否有返回值，都可以省略大括号、return关键字及语句分号

    注意：
    使用Lambda必须具有接口，且要求接口中有且仅有一个抽象方法。 无论是JDK内置的Runnable 、 Comparator接口还是自定义的接口，只有当接口中的抽象方法存在且唯一时，才可以使用Lambda。
    使用Lambda必须具有上下文推断。也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。
    备注：有且仅有一个抽象方法的接口，称为“函数式接口”。

# day08_File类、递归

java.io.File
类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。

File f = new File(“D:/aaa/bbb.java”);

一个File对象代表硬盘中实际存在的一个文件或者目录。

无论该路径下是否存在文件或者目录，都不影响File对象的创建。

## 获取功能的方法：

public String getAbsolutePath() ：返回此File的绝对路径名字符串。
public String getPath() ：将此File转换为路径名字符串。

public String getName() ：返回由此File表示的文件或目录的名称。
public long length() ：返回由此File表示的文件的长度。

## 判断功能的方法：

public boolean exists() ：此File表示的文件或目录是否实际存在。
public boolean isDirectory() ：此File表示的是否为目录。

public boolean isFile() ：此File表示的是否为文件

## 创建删除功能的方法：

public boolean createNewFile()
：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。

public boolean delete() ：删除由此File表示的文件或目录。 public boolean mkdir()
：创建由此File表示的目录。

public boolean mkdirs() ：创建由此File表示的目录，包括任何必需但不存在的父目录。

## 目录的遍历：

public String[] list()
：返回一个String数组，表示该File目录中的所有子文件或目录。

public File[] listFiles()
：返回一个File数组，表示该File目录中的所有的子文件或目录

绝对路径：从盘符开始的路径，这是一个完整的路径。

相对路径：相对于项目目录的路径，这是一个便捷的路径，开发中经常使用

递归

    注意：递归一定要有条件限定，保证递归能够停止下来，否则会发生栈内存溢出。在递归中虽然有限定条件，但是递归次数不能太多。否则也会发生栈内存溢出。构造方法,禁止递归。

![](/assets/image/media/ff78a73cb4e19be031e278e62b67e45d.png)

文件过滤器优化

java.io.FileFilter是一个接口，是File的过滤器，可以传递给File类的
listFiles(FileFilter) 作为参数。

boolean accept(File pathname)
：测试pathname是否应该包含在当前File目录中，符合则返回true。

![](/assets/image/media/706e07c36f4c1f1b173e5bd5011b053f.png)

# day09_字节流、字符流

Java中I/O操作主要是指使用 java.io

## 以内存为基准，分为
输入input(读取) ：把数据从其他设备上读取到内存中的流
输出 output(写出) ：把数据从内存中写出到其他设备上的流

## 格局数据的类型分为
### 字节流 ：InputStream(字节输入流)：

>   public void close() ：关闭此输入流并释放与此流相关联的任何系统资源。
>   public abstract int read() ： 从输入流读取数据的下一个字节。每次可以读取一个字节的数据，提升为int类型，读取到文件末尾，返回 -1

>   public int read(byte[] b) ：
>   从输入流中读取一些字节数，并将它们存储到字节数组 b中 。

>    System.out.println(new String(b，0，len));使用数组读取，每次读取多个字节，减少了系统间的IO操作次数，从而提高了读写的效率，建议开发中使用。

#### 子类：
java.io.FileInputStream类是文件输入流，从文件中读取字节。
你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有该文件,会抛出FileNotFoundException

### OutputStream(字节输出流)：

>   public void close() ：关闭此输出流并释放与此流相关联的任何系统资源。

>   **close方法，当完成流的操作时，必须调用此方法，释放系统资源**
>   public void flush() ：刷新此输出流并强制任何缓冲的输出字节被写出。
>   public void write(byte[] b) ：将 b.length字节从指定的字节数组写入此输出流。

>   public void write(byte[] b, int off, int len) ：从指定的字节数组写入
>   len字节，从偏移量 oﬀ开始输 出到此输出流。

>   public abstract void write(int b) ：将指定的字节输出流。

#### 子类：

java.io.FileOutputStream类是文件输出流，用于将数据写出到文件。

当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有这个文件，会创建该文件。如果有这个文
件，会清空这个文件的数据。


##### 数据追加续写

>   public FileOutputStream(File file, boolean append) ：
>   创建文件输出流以写入由指定的 File对象表示的 文件。
>   public FileOutputStream(String name, boolean append) ：
>   创建文件输出流以指定的名称写入文件。

参数中都需要传入一个boolean类型的值， true 表示追加数据， false
表示清空原有数据。

### 字符流 ：

Reader(字符输入流)：

>   public void close() ：关闭此流并释放与此流相关联的任何系统资源。
>   public int read() ： 从输入流读取一个字符。

>   每次可以读取一个字符的数据，提升为int类型

>   public int read(char[] cbuf) ：
>   从输入流中读取一些字符，并将它们存储到字符数组 cbuf中 。

>   System.out.println(new String(cbuf,0,len));

#### 子类：

java.io.FileReader构造时使用系统默认的字符编码(GBK/UTF-8)和默认字节缓冲区(字节数组，临时存储字节数据)。

### Writer(字符输出流)：

> void write(int c) 写入单个字符。

>   void write(char[] cbuf) 写入字符数组。
>   abstract  void write(char[] cbuf, int off, int len)
>   写入字符数组的某一部分,oﬀ数组的开始索引,len 写的字符个数。

>   void write(String str) 写入字符串。

>   void write(String str, int off, int len)
>   写入字符串的某一部分,oﬀ字符串的开始索引,len写的字符个 数。

>   void flush() 刷新该流的缓冲，流对象可以继续使用

>   void close() 关闭此流，但要先刷新它。

#### 子类：

java.io.FileWriter构造时使用系统默认的字符编码和默认字节缓冲区。未调用close方法，数据只是保存到了缓冲区，并未写出到文件中。

字节流可以传输任意文件数据。在操作流的时候，我们要时刻明确，无论使用什么样的流对象，底层传输的始终为二进制数据。

字符流，只能操作文本文件，不能操作图片，视频等非文本文件。当我们单纯读或者写文本文件时使用字符流，其他情况使用字节流

## IO异常的处理

实际开发中，建议使用try...catch...finally代码块，处理异常部分
还可以使用JDK7优化后的 try-with-resource
语句，该语句确保了每个资源在语句结束时关闭。所谓的资源（resource）是指在程序完成后，必须关闭的对象
```java
try (创建流对象语句，如果多个,使用';'隔开) {

// 读写数据     

} catch (IOException e) {

 e.printStackTrace();     

 }
 ```

JDK9中 try-with-resource
的改进，对于引入对象(直接引入)的方式，支持的更加简洁。被引入的对象，同样可以自动关闭，
无需手动close

属性集

java.util.Properties 继承于Hashtable，来表示一个持久的属性集。它使用键值结构存储数据，每个键及其
对应值都是一个字符串。

### 基本的存储方法：

>   public Object setProperty(String key, String value) ： 保存一对属性。
>   public String getProperty(String key) ：使用此属性列表中指定的键搜索属性值。

>   public Set\<String\> stringPropertyNames() ：所有键的名称的集合

### 与流相关的方法

>   public void load(InputStream inStream) ： 从字节输入流中读取键值对。

>   文本中的数据，必须是键值对形式，可以使用空格、等号、冒号等符号分隔。

# day10_缓冲流、转换流、序列化流、Files
缓冲流,也叫高效流，在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。冲流读写方法与基本的流是一致的

## 字节缓冲流：

### BufferedInputStream
BufferedInputStream bis = new BufferedInputStream(new FileInputStream("bis.txt"));

### BufferedOutputStream

BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("bos.txt"));

## 字符缓冲流：

### BufferedReader

>   BufferedReader br = new BufferedReader(new FileReader("br.txt"));
public String readLine() : 读一行文字

### BufferedWriter

>   BufferedWriter bw = new BufferedWriter(new FileWriter("bw.txt"));
public void newLine() : 写一行行分隔符,由系统属性定义符号

转换流

字符编码 Character Encoding : 就是一套自然语言的字符与二进制数之间的对应规则。

字符集 Charset：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符
号、数字等

IDEA的设置，都是默认的 UTF-8
编码，所以没有任何问题。但是，当读取Windows系统中创建的文本文件时，由于Windows系统的默认是GBK编码，就会出现乱码。

java.io.InputStreamReader，是Reader的子类，它读取字节，并使用指定的字符集(名称指定/默认字符集)将其解码为字符

InputStreamReader isr = new InputStreamReader(new FileInputStream("in.txt"));
InputStreamReader isr2 = new InputStreamReader(new FileInputStream("in.txt") , "GBK");

java.io.OutputStreamWriter，是Writer的子类，使用指定的字符集将字符编码为字节

![](/assets/image/media/c0bf32e564d0660f7fc47026025303a3.png)

序列化

Java 提供了一种对象序列化的机制。用一个字节序列(包含该对象的数据 、
对象的类型和对象中存储的属性等信息)可以表示一个对象，写出到文件之后，相当于文件中持久保存了一个对象的信息。

![](/assets/image/media/260dae50e88fd251e5fc80a7fc174364.png)

java.io.ObjectOutputStream
类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。

ObjectOutputStream out =  new ObjectOutputStream(new FileOutputStream("employee.txt"));

序列化操作

满足两个条件

该类必须实现 java.io.Serializable 接口， Serializable
是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出
NotSerializableException 。

该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用
transient 关键字修饰。

写出对象方法

public final void writeObject (Object obj) : 将指定的对象写出

out.writeObject(e);

out.close();

fileOut.close();

反序列化

ObjectInputStream in = new ObjectInputStream(new
FileInputStream("employee.txt"));

e = (Employee)in.readObject();

in.close();

fileIn.close();

对于JVM可以反序列化对象，它必须是能够找到class文件的类。

如果找不到该类的class文件，则抛出一个 ClassNotFoundException 异常

class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个
InvalidClassException 异常。

原因：该类的序列版本号与从流中读取的类描述符的版本号不匹配该类包含未知数据类型该类没有可访问的无参数构造方法

Serializable 接口给需要序列化的类，提供了一个序列版本号。 serialVersionUID该版本号的目的在于验证序列化的对象和对应类是否版本匹配

打印流

java.io.PrintStream
类，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。

构造方法

public PrintStream(String fileName) ： 使用指定的文件名创建一个新的打印流。

改变打印流向

PrintStream ps = new PrintStream("ps.txt");

System.setOut(ps);

day11_网络编程

C/S结构 ：全称为Client/Server结构，是指客户端和服务器结构。

B/S结构 ：全称为Browser/Server结构，是指浏览器和服务器结构。

网络编程，就是在一定的协议下，实现两台计算机的通信的程序。

TCP/IP协议： 传输控制协议/因特网互联协议( Transmission Control Protocol/Internet
Protocol)，是
Internet最基本、最广泛的协议。它定义了计算机如何连入因特网，以及数据如何在它们之间传输的标准。它
的内部包含一系列的用于处理数据通信的协议，并采用了4层的分层模型，每一层都呼叫它的下一层所提供的
协议来完成自己的需求。

java.net
包提供低层次的通信细节，可以直接使用这些类和接口，来专注于网络程序开发。

提供了两种常见的网络协议的支持：
