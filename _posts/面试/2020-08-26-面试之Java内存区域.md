---
layout: post
title: "面试之Java内存区域"
subtitle: "「Java内存区域」"
author: "月明"
date: 2020-08-26 14:10:00
author: "月明"
header-img: "assets/background2.png"
header-mask: 0.3
tags:
  - Java
  - 面试
  - 内存区域
---

# 内存区域

> 对于 Java 程序员来说，在虚拟机自动内存管理机制下，不容易出现内存泄漏和内存溢出问题。正是因为 Java 程序员把内存控制权利交给 Java 虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会是一个非常艰巨的任务。

## 运行时数据区域

Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。

![](/assets/image/JDK1.6-运行时数据区域.png)

线程私有的：

* 虚拟机栈
* 本地方法栈
* 程序计数器

### 2.1 虚拟机栈

> **Java虚拟机栈是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型。**
>
> **Java 内存可以粗糙的区分为``堆内存（Heap）``和``栈内存(Stack)``,其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。**
>
> （实际上，Java虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。）

**局部变量表主要存放了编译器可知的各种数据类型**`（boolean、byte、char、short、int、float、long、double）`、**``对象引用``**（reference类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。

**Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError**

* **StackOverFlowError：** 若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就抛出StackOverFlowError异常。
* **OutOfMemoryError：** 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出OutOfMemoryError异常。

### 2.2 本地方法栈

和虚拟机栈所发挥的作用非常相似，区别是： **虚拟机栈为虚拟机执行 `Java 方法` （也就是``字节码``）服务，而本地方法栈则为虚拟机使用到的` Native `方法服务。** 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。

本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。

方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种异常。

### 2.3 程序计数器

> **每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。**
>
> **程序计数器是唯一一个不会出现OutOfMemoryError的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。**

* 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
* 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。			

线程共享的：

* 堆
* 方法区
* 直接内存

### 2.4 堆

> Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。**此内存区域的唯一目的就是``存放对象实例``，几乎所有的对象实例以及数组都在这里分配内存。**

Java 堆是``垃圾收集器管理``的主要区域，因此也被称作**``GC堆（Garbage Collected Heap）``**.从垃圾回收的角度，由于现在收集器基本都采用**分代垃圾收集算法**，所以Java堆还可以细分为：``新生代``和``老年代``：再细致一点有：Eden空间、From Survivor、To Survivor空间等。**进一步划分的目的是更好地回收内存，或者更快地分配内存。**

**在 JDK 1.8中移除整个永久代，取而代之的是一个叫``元空间（Metaspace）``的区域（永久代使用的是JVM的堆内存空间，而元空间使用的是``物理内存``，直接受到本机的物理内存限制）。**

![](/assets/image/6174a2431b27e70f194eb6fa7a2f33a.png)

### 2.5 方法区

> **它用于存储已被虚拟机加载的``类信息``、``常量``、``静态变量``、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 `Non-Heap（非堆）`，目的应该是与 Java 堆区分开来。**

HotSpot 虚拟机中方法区也常被称为 **“永久代”**，本质上两者并不等价。仅仅是因为 HotSpot 虚拟机设计团队用永久代来实现方法区而已，这样 HotSpot 虚拟机的垃圾收集器就可以像管理 Java 堆一样管理这部分内存了。但是这并不是一个好主意，因为这样更容易遇到内存溢出问题。

**相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了**

### 2.6 直接内存

> 直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 异常出现。

JDK1.4中新加入的 **NIO(New Input/Output) 类**，引入了一种基于**通道（Channel）** 与**缓存区（Buffer）** 的 I/O 方式，它可以直接使用Native函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为**避免了在 Java 堆和 Native 堆之间来回复制数据**。

本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。

### 2.7 运行时常量池

> 运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用）
>
> 既然运行时常量池时方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。

**JDK1.7及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。**

## HotSpot 虚拟机对象

> HotSpot 虚拟机在 Java 堆中对象分配、布局和访问的全过程。

### 3.1 对象的创建

**①``类加载检查``：** 虚拟机遇到一条 `new `指令时，首先将去检查这个指令的参数是否能在``常量池``中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。**如果没有，那必须先执行相应的类加载过程。**

**②``分配内存``：** 在**类加载检查**通过后，接下来虚拟机将为新生对象**分配内存**。对象所需的``内存大小``在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存``从 Java 堆中划分``出来。**分配方式**有 **“``指针碰撞``”** 和 **“``空闲列表``”** 两种，**选择哪种分配方式由 Java 堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有``压缩整理功能``决定**。

> **内存分配的两种方式：（补充内容，需要掌握）**
>
> 选择以上两种方式中的哪一种，取决于 Java 堆内存``是否规整``。而 Java 堆内存是否规整，取决于 GC 收集器的算法是"``标记-清除``"，还是"``标记-整理``"（也称作"``标记-压缩``"），**值得注意的是，复制算法内存也是规整的。**

![](/assets/image/274b8b34848378b845908bb9056a055.png)

> **内存分配并发问题（补充内容，需要掌握）**
>
> 在创建对象的时候有一个很重要的问题，就是``线程安全``，因为**在实际开发过程中，创建对象是很频繁的事情**，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：
>
> * **``CAS+失败重试``：** CAS 是``乐观锁``的一种实现方式。所谓乐观锁就是，**`每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。`**虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。**
> * **`TLAB`：** 为每一个线程``预先在Eden区分配一块儿内存``，JVM在给线程中的对象分配内存时，首先在TLAB分配，当对象大于TLAB中的剩余内存或TLAB的内存已用尽时，再采用上述的CAS进行内存分配。

**③``初始化零值``：** 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（``不包括对象头``），这一步操作保证了对象的实例字段在 Java 代码中``可以不赋初始值就直接使用``，程序能访问到这些字段的数据类型所对应的零值。

**④``设置对象头``：** 初始化零值完成之后，**虚拟机要对对象进行必要的设置**，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 **这些信息存放在对象头中。** 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。

**⑤``执行 init 方法``：** 在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，`<init>` 方法还没有执行，所有的字段都还为零。所以一般来说，**执行 new 指令之后会接着执行 `<init>` 方法**，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。

### 3.2 对象的内存布局

在 Hotspot 虚拟机中，对象在内存中的布局可以分为3块区域：**``对象头``**、**``实例数据``**和**``对齐填充``**。

**Hotspot虚拟机的对象头包括两部分信息**，**第一部分用于存储对象自身的``自身运行时数据``**（哈希码、GC分代年龄、锁状态标志等等），**另一部分是``类型指针``**，即对象指向它的``类元数据``的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。

**实例数据部分是对象真正存储的有效信息**，也是在程序中所定义的各种类型的字段内容。

**对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅``起占位作用``。** 因为Hotspot虚拟机的自动内存管理系统要求对象起始地址必须是``8字节的整数倍``，换句话说就是对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数（1倍或2倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。

### 3.3 对象的访问定位

建立对象就是为了使用对象，我们的Java程序通过栈上的 `reference 数据`来操作堆上的具体对象。对象的访问方式有虚拟机实现而定，目前主流的访问方式有**①使用句柄**和**②直接指针**两种：

1. **``句柄``：** 如果使用句柄的话，那么Java堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的``句柄地址``，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；
2. **``直接指针``：** 如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference 中存储的直接就是``对象的地址``。

**这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身``不需要修改``。**

**使用直接指针访问方式最大的好处就是``速度快``，它节省了一次指针定位的时间开销。**

## 重点补充内容

### 4.1 String 类和常量池

> 只要使用new方法，便需要创建新的对象。

* 直接使用双引号声明出来的 String 对象会直接存储在常量池中。
* 如果不是用双引号声明的 String 对象，可以使用 String 提供的 intern 方法。String.intern() 是一个 Native 方法，它的作用是：如果运行时常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用；如果没有，则在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用。

> 尽量避免多个字符串拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用 StringBuilder 或者 StringBuffer。

### 4.2 8种基本类型的包装类和常量池

* **Java 基本类型的包装类的大部分都实现了常量池技术，即Byte,Short,Integer,Long,Character,Boolean；这5种包装类默认创建了数值[-128，127]的相应类型的缓存数据，但是超出此范围仍然会去创建新的对象。**
* **两种浮点数类型的包装类 Float,Double 并没有实现常量池技术。**



