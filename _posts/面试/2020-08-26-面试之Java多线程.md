---
layout: post
title: "面试之Java多线程"
subtitle: "「Java多线程」"
author: "月明"
date: 2020-08-26 13:23:00
author: "月明"
header-img: "assets/background1.png"
header-mask: 0.3
tags:
  - Java
  - 面试
  - 多线程
---

# 多线程

> 进程是程序的⼀次执⾏过程，是系统运⾏程序的基本单位，因此进程是``动态``的。系统运⾏⼀个程序即是 ⼀个进程从创建，运⾏到消亡的过程。

在 Java 中，当我们启动 main 函数时其实就是启动了⼀个 `JVM 的进程`，⽽ main 函数所在的线程就是这个进程中的⼀个线程，也称``主线程``。

与进程不同的是同类的多个线程共享进程的**堆**和**⽅法区**资源，但每个线程有⾃⼰的**程序计数器**、**虚拟机栈**和**本地⽅法栈**，所以系统在产⽣⼀个线程，或是在各个线程之间作切换⼯作时，负担要⽐进程⼩得多，也正因为如此，线程也被称为**轻量级进程**。

⼀个 Java 程序的运⾏是 main 线程和多个其他线程同时运⾏。

# 1.请简要描述线程与进程的关系,区别及优缺点？

> 从 JVM ⻆度说进程和线程之间的关系

⼀个进程中可以有多个线程，多个线程共享进程的堆和⽅法区 (JDK1.8 之后的元空 间)资源，但是每个线程有⾃⼰的程序计数器、虚拟机栈 和 本地⽅法栈。

总结： 线程是进程划分成的更⼩的运⾏单位。线程和进程最⼤的不同在于基本上各进程是独⽴的， ⽽各线程则不⼀定，因为同⼀进程中的线程极有可能会相互影响。线程执⾏开销⼩，但不利于资源的管 理和保护；⽽进程正相反。

## 程序计数器为什么是私有的?

程序计数器主要有下⾯两个作⽤：

* 字节码解释器通过改变程序计数器来依次读取指令，从⽽实现代码的流程控制，如：顺序执⾏、 选择、循环、异常处理。
*  在多线程的情况下，程序计数器⽤于记录当前线程执⾏的位置，从⽽当线程被切换回来的时候能 够知道该线程上次运⾏到哪⼉了。

需要注意的是，如果执⾏的是 native ⽅法，那么程序计数器记录的是 undefined 地址，只有执⾏的 是 Java 代码时程序计数器记录的才是下⼀条指令的地址。

所以，程序计数器私有主要是``为了线程切换后能恢复到正确的执⾏位置``。

## 虚拟机栈和本地⽅法栈为什么是私有的?

* 虚拟机栈： 每个 Java ⽅法在执⾏的同时会创建⼀个栈帧⽤于存储局部变量表、操作数栈、常 量池引⽤等信息。从⽅法调⽤直⾄执⾏完成的过程，就对应着⼀个栈帧在 Java 虚拟机栈中⼊栈 和出栈的过程。
* 本地⽅法栈： 和虚拟机栈所发挥的作⽤⾮常相似，区别是： 虚拟机栈为虚拟机执⾏ Java ⽅法 （也就是字节码）服务，⽽本地⽅法栈则为虚拟机使⽤到的 Native ⽅法服务。 在 HotSpot 虚 拟机中和 Java 虚拟机栈合⼆为⼀。

所以，为了保证线程中的``局部变量不被别的线程访问到``，虚拟机栈和本地⽅法栈是线程私有的。

## ⼀句话简单了解堆和⽅法区

堆和⽅法区是所有线程共享的资源，其中堆是进程中最⼤的⼀块内存，主要⽤于存放新创建的对象 (所 有对象都在这⾥分配内存)，⽅法区主要⽤于存放已被加载的类信息、常量、静态变量、即时编译器编 译后的代码等数据。

# 2.说说并发与并⾏的区别?

* 并发： `同⼀时间段`，多个任务都在执⾏ (单位时间内不⼀定同时执⾏)；
* 并⾏： 单位时间内，多个任务``同时``执⾏。

# 3.为什么要使⽤多线程呢?

先从总体上来说：

* 从计算机底层来说： 线程可以⽐作是轻量级的进程，是程序执⾏的最⼩单位,线程间的切换和调度的成本远远⼩于进程。另外，多核 CPU 时代意味着多个线程可以同时运⾏，这减少了线程上下⽂切换的开销。

  再深⼊到计算机底层来探讨：

  * 单核时代： 在单核时代多线程主要是为了提⾼ CPU 和 IO 设备的综合利⽤率。

    > 举个例⼦：当只有⼀个线程的时候会导致 CPU 计算时，IO 设备空闲；进⾏ IO 操作时，CPU 空闲。我们可以简 单地说这两者的利⽤率⽬前都是 50%左右。但是当有两个线程的时候就不⼀样了，当⼀个线程执 ⾏ CPU 计算时，另外⼀个线程可以进⾏ IO 操作，这样两个的利⽤率就可以在理想情况下达到 100%了。

  * 多核时代: 多核时代多线程主要是为了提⾼ CPU 利⽤率。

    > 举个例⼦：假如我们要计算⼀个复杂 的任务，我们只⽤⼀个线程的话，CPU 只会⼀个 CPU 核⼼被利⽤到，⽽创建多个线程就可以让 多个 CPU 核⼼被利⽤到，这样就提⾼了 CPU 的利⽤率。

* 从当代互联⽹发展趋势来说： 现在的系统动不动就要求百万级甚⾄千万级的并发量，⽽多线程 并发编程正是开发⾼并发系统的基础，利⽤好多线程机制可以⼤⼤提⾼系统整体的并发能⼒以及 性能。

# 4.使⽤多线程可能带来什么问题?

并发编程的⽬的就是为了能提⾼程序的``执⾏效率``，提⾼程序运⾏速度，但是并发编程并不总是能提⾼程序运⾏速度的，⽽且并发编程可能会遇到很多问题，⽐如：**内存泄漏、上下⽂切换、死锁还有受限于硬件和软件的资源闲置问题**。

# 5.说说线程的⽣命周期和状态?

![](/assets/image/5052dd00c7076a48aaa48120e05aa07.png)

线程在⽣命周期中并不是固定处于某⼀个状态⽽是随着代码的执⾏在不同状态之间切换。

线程创建之后它将处于`` NEW（新建） `状态，调⽤` start() `⽅法后开始运⾏，线程 这时候处于 `READY（可运⾏）`` 状态。可运⾏状态的线程获得了 `CPU 时间⽚（timeslice）`后就处于 `RUNNING（运⾏） `状态。

当线程执⾏ `wait() `⽅法之后，线程进⼊`` WAITING（等待）`` 状态。进⼊等待状态的线程需要依靠其他 线程的通知才能够返回到运⾏状态，⽽ `TIME_WAITING(超时等待) `状态相当于在等待状态的基础上增加 了超时限制，⽐如通过`` sleep（long millis） `⽅法或 `wait（long millis）`` ⽅法可以将 Java 线程置于`` TIMED WAITING `状态。当超时时间到达后 Java 线程将会返回到` RUNNABLE `状态。当线程调⽤同步 ⽅法时，在没有获取到锁的情况下，线程将会进⼊到 `BLOCKED（阻塞）`状态。线程在执⾏ Runnable 的 `run() `⽅法之后将会进⼊到 `TERMINATED（终⽌）` 状态。

> 操作系统隐藏 Java 虚拟机（JVM）中的 RUNNABLE 和 RUNNING 状态，它只能看到 RUNNABLE 状态 ，所以 Java 系统⼀般将 这两个状态统称为 RUNNABLE（运⾏中） 状态 。

# 6.什么是上下⽂切换?

多线程编程中⼀般线程的个数都⼤于 CPU 核⼼的个数，⽽⼀个 CPU 核⼼在任意时刻只能被⼀个线程使⽤，为了让这些线程都能得到有效执⾏，**CPU 采取的策略是`为每个线程分配时间⽚并轮转`的形式**。**当⼀个线程的时间⽚⽤完的时候就会``重新处于就绪状态``让给其他线程使⽤，这个过程就属于⼀次上下⽂切换。**

当前任务在执⾏完 CPU 时间⽚切换到另⼀个任务之前会先保存⾃⼰的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是⼀次上下⽂切换。

上下⽂切换通常是``计算密集型``的。也就是说，它需要相当可观的处理器时间，在每秒⼏⼗上百次的切换 中，每次切换都需要纳秒量级的时间。所以，上下⽂切换对系统来说意味着消耗⼤量的 CPU 时间，事实上，可能是操作系统中时间消耗最⼤的操作。

Linux 相⽐与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有⼀项就是，其上下⽂切换 和模式切换的时间消耗⾮常少。

# 7.什么是线程死锁?如何避免死锁?

> 多个线程同时被阻塞，它们中的⼀个或者全部都在等待某个资源被释 放。由于线程被⽆限期地阻塞，因此程序不可能正常终⽌。

产⽣死锁必须具备以下四个条件：

* 互斥条件：该资源任意⼀个时刻只由⼀个线程占⽤。
* 请求与保持条件：⼀个进程因请求资源⽽阻塞时，对已获得的资源保持不放。
* 不剥夺条件:线程已获得的资源在末使⽤完之前不能被其他线程强⾏剥夺，只有⾃⼰使⽤完毕后 才释放资源。
* 循环等待条件:若⼲进程之间形成⼀种头尾相接的循环等待资源关系。

## 如何避免线程死锁?

> 为了避免死锁，我们只要破坏产⽣死锁的四个条件中的其中⼀个 就可以了。

* 破坏互斥条件 ：这个条件我们没有办法破坏，因为我们⽤锁本来就是想让他们互斥的（临界资 源需要互斥访问）。
*  破坏请求与保持条件 ：⼀次性申请所有的资源。
* 破坏不剥夺条件 ：占⽤部分资源的线程进⼀步申请其他资源时，如果申请不到，可以主动释放 它占有的资源。
* 破坏循环等待条件 ：靠按序申请资源来预防。按某⼀顺序申请资源，释放资源则反序释放。破 坏循环等待条件。

# 8.说说 sleep() ⽅法和 wait() ⽅法区别和共同点?

* 两者最主要的区别在于：sleep ⽅法没有释放锁，⽽ wait ⽅法释放了锁 。
* 两者都可以暂停线程的执⾏。
* Wait 通常被⽤于线程间交互/通信，sleep 通常被⽤于暂停执⾏。
* wait() ⽅法被调⽤后，线程不会⾃动苏醒，需要别的线程调⽤同⼀个对象上的 notify() 或者 notifyAll() ⽅法。sleep() ⽅法执⾏完成后，线程会⾃动苏醒。或者可以使⽤ wait(long timeout)超时后线程会⾃动苏醒。

# 9.为什么我们调⽤ start() ⽅法时会执⾏ run() ⽅法，为什么我们不能直接调⽤ run() ⽅法？

> 这是另⼀个⾮常经典的 java 多线程⾯试问题，⽽且在⾯试中会经常被问到。很简单，但是很多⼈都会答不上来！

new ⼀个 Thread，线程进⼊了新建状态;调⽤ start() ⽅法，会启动⼀个线程并使线程进⼊了就绪状 态，当分配到时间⽚后就可以开始运⾏了。 start() 会执⾏线程的相应准备⼯作，然后⾃动执⾏ run() ⽅法的内容，这是真正的多线程⼯作。 ⽽直接执⾏ run() ⽅法，会把 run ⽅法当成⼀个 main 线程下的普通⽅法去执⾏，并不会在某个线程中执⾏它，所以这并不是多线程⼯作。

总结： 调⽤ start ⽅法⽅可启动线程并使线程进⼊就绪状态，⽽ run ⽅法只是 thread 的⼀个普通⽅法调⽤，还是在主线程⾥执⾏。

# 10.synchronized 关键字

## 说⼀说⾃⼰对于 synchronized 关键字的了解

synchronized关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰 的⽅法或者代码块在任意时刻只能有⼀个线程执⾏。

另外，在 Java 早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依 赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原⽣线程之上的。如 果要挂起或者唤醒⼀个线程，都需要操作系统帮忙完成，⽽操作系统实现线程之间的切换时需要从⽤户 态转换到内核态，这个状态之间的转换需要相对⽐较⻓的时间，时间成本相对较⾼，这也是为什么早期 的 synchronized 效率低的原因。庆幸的是在 Java 6 之后 Java 官⽅对从 JVM 层⾯对synchronized 较⼤优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6对锁的实现引⼊了⼤量的优 化，如⾃旋锁、适应性⾃旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。

## 说说⾃⼰是怎么使⽤ synchronized 关键字，在项⽬中⽤到了吗？

